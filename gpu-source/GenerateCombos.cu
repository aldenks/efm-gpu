#include "GenerateCombos.h"

//This function calculates metabolite coefficients of a single new combination
//Param result: Pointer to the first metabolite coeffiient of the new combination
//Param p1: Pointer to the first metabolite coeffiient of the first pathway
//Param p2: Pointer to the first metabolite coeffiient of the second pathway
//Param scale: Scaling factor for the second pathway
//Param metaboliteCount: The number of metabolites in a pathway

__device__
void scalePathway(float* result, float* p1, float* p2, float scale, int metaboliteCount) {
   float ans;
   for (int i = 0; i < metaboliteCount; i++) {
      ans = p1[i] + p2[i] * scale;
      //Explicitly setting the coefficient to zero based on the tolerence
      //This is done to avoid accomulation of floating point error
      if (NEG_ZERO < ans && ans < ZERO) {
         ans = 0;
      }
      result[i] = ans;
   }
}

//This function generates combinations.
//Param bins: Pointer to the combination bins
//Param indicies: Pointer to the array of indicies in the pathway buffers where each thread is going to store combinations
//Param inputIndex: Starting index of the input pathways in the pathway buffers
//Param numberOfBins: Total number of bins / inputs
//Param metabolite: The metabolite that is balanced
//Param metaboliteCount: Number of metabolites in each pathway
//Param reactions: Pointer to the binary vectors buffer
//Param metaboliteCoefficients: Pointer to the metabolite coefficient buffer

__global__
void generateCombinations(int* bins, int* indicies, int inputIndex, int numberOfBins, int metabolite, int metaboliteCount, BinaryVector *reactions, float *metaboliteCoefficients) {
   //Thread id for current thread
   int tid = blockIdx.x * blockDim.x + threadIdx.x;
   //Checking for valid thread id
   if (tid >= numberOfBins) {
      return;
   }
   //Index in the pathway buffers where current thread is going to write new combinations
   int writeIndex = circularIndex(indicies[tid]);
   //Setting pointer to point to the first element in combinations bins. This points to the number of combinations
   bins += tid;
   //Reading number of combination to be generated by current thread
   int writeCount = *bins;
   //Translating input index to circular buffer index
   inputIndex = circularIndex(inputIndex + tid);
   //Reading binary representation of input pathway
   BinaryVector inputReaction = reactions[inputIndex];
   //Index pointing to the output pathways for generating new combinations
   int outputIndex;
   //Metabolite coefficients corresponding to the metabolite being balanced in input and output pathways
   float met1, met2;
   //This for loop iterates over the output pathways which are to be combined with the input pathway for current thread
   for (int i = 0; i < writeCount; i++, writeIndex = circularIndex(writeIndex + 1)) {
      //Updating pointer to point to the next index of output pathway
      bins += numberOfBins;
      //Reading the index of output pathway
      outputIndex = circularIndex(*bins);
      //Generating binary vector for the new combination
      reactions[writeIndex] = inputReaction | reactions[outputIndex];
      //Reading metabolite coefficients for the current metabolite being balanced
      met1 = metaboliteCoefficients[metaboliteCount * inputIndex + metabolite];
      met2 = metaboliteCoefficients[metaboliteCount * outputIndex + metabolite];
      //Making sure to scale up in order to avoid the coefficients to drop below the zero tolerance defined by constants ZERO and NEG_ZERO
      if (-met1 < met2) {
         scalePathway(metaboliteCoefficients + metaboliteCount * writeIndex, metaboliteCoefficients + metaboliteCount * inputIndex, metaboliteCoefficients + metaboliteCount * outputIndex, -met1 / met2, metaboliteCount);
      } else {
         scalePathway(metaboliteCoefficients + metaboliteCount * writeIndex, metaboliteCoefficients + metaboliteCount * outputIndex, metaboliteCoefficients + metaboliteCount * inputIndex, -met2 / met1, metaboliteCount);
      }
      //Setting metabolite coefficient of the metabolite being balanced to
      metaboliteCoefficients[metaboliteCount * writeIndex + metabolite] = 0;
   }
}

//This function generates combinations after dependency checks have identified independent
//input output pairs. The process of generation includes generating binary bit vectors and
//metabolite coefficients of the combinations.
//Param metabolite: The metabolite being balanced
//Param numberOfBin: Number of bins in combination bin array
//Param nextFreePathwayIndex: Index in the pathway buffers to store new pathways

int generateCombinations(int metabolite, int numberOfBins, int nextFreePathwayIndex) {
   cudaError err;
   //Copying count of new combinations generated by each thread in dependency checking
   err = cudaMemcpy(h_combinationBinCounts, d_combinationBins, numberOfBins * sizeof (int), cudaMemcpyDeviceToHost);
   if (err != cudaSuccess) {
      fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", __FILE__, __LINE__, cudaGetErrorString(err));
   }
   //First thread is going to store combinations at nextFreePathwayIndex
   h_combinationWriteIndices[0] = nextFreePathwayIndex;
   //Counting number of new combinations
   int newComboCount = h_combinationBinCounts[0];
   for (int i = 1; i < numberOfBins; i++) {
      //Updating indices for rest of the threads
      h_combinationWriteIndices[i] = h_combinationWriteIndices[i - 1] + h_combinationBinCounts[i - 1];
      //Updating number of new pathway count
      newComboCount += h_combinationBinCounts[i];
   }
   //Updating GPU memory with write indices
   err = cudaMemcpy(d_combinationWriteIndices, h_combinationWriteIndices, numberOfBins * sizeof (int), cudaMemcpyHostToDevice);
   if (err != cudaSuccess) {
      fprintf(stderr, "Cuda error in file '%s' in line %i : %s.\n", __FILE__, __LINE__, cudaGetErrorString(err));
   }
   //Number of blocks required for the given number of bins
   int numBlocks = ((numberOfBins - 1) / MAX_THREADS_PER_BLOCK) + 1;
   //Calling GPU kernel to generate new combinations
   generateCombinations << < numBlocks, MAX_THREADS_PER_BLOCK >> > (d_combinationBins, d_combinationWriteIndices, pathwayStartIndex, numberOfBins, metabolite, metaboliteCount, d_binaryVectors, d_metaboliteCoefficients);
   return newComboCount;
}
